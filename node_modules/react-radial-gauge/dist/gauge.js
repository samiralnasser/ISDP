'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var TICK_ID = 'tick';

var Gauge = function (_Component) {
    _inherits(Gauge, _Component);

    function Gauge() {
        var _ref;

        var _temp, _this, _ret;

        _classCallCheck(this, Gauge);

        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }

        return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = Gauge.__proto__ || Object.getPrototypeOf(Gauge)).call.apply(_ref, [this].concat(args))), _this), _this.renderDial = function (opts) {
            return _react2.default.createElement('circle', {
                cx: opts.cX,
                cy: opts.cY,
                r: opts.radius,
                fill: 'none',
                stroke: opts.dialColor,
                strokeWidth: opts.dialWidth
            });
        }, _this.defineTick = function (opts) {
            var tX1 = opts.cX + opts.radius - Math.max(opts.dialWidth, opts.progressWidth) / 2;
            var tX2 = tX1 - opts.tickLength;

            return _react2.default.createElement('line', {
                id: TICK_ID,
                x1: tX1,
                y1: opts.cY,
                x2: tX2,
                y2: opts.cY,
                stroke: opts.tickColor,
                strokeWidth: opts.tickWidth
            });
        }, _this.renderTicks = function (opts) {
            var tickAngles = [];
            for (var i = 0; i <= 360; i += opts.tickInterval) {
                tickAngles.push(i);
            }
            return _react2.default.createElement(
                'g',
                { className: 'ticks' },
                tickAngles.map(function (tickAngle, idx) {
                    return _react2.default.createElement('use', {
                        href: '#' + TICK_ID,
                        key: 'tick-' + idx,
                        transform: 'rotate(' + tickAngle + ' ' + opts.cX + ' ' + opts.cY + ')'
                    });
                })
            );
        }, _this.renderProgress = function (opts) {

            var offset = opts.circumference * (1 - opts.currentValue / 100);

            return _react2.default.createElement('circle', {
                cx: opts.cX,
                cy: opts.cY,
                r: opts.radius,
                fill: 'none',
                stroke: opts.progressColor,
                strokeWidth: opts.progressWidth,
                strokeDasharray: opts.circumference,
                strokeDashoffset: offset,
                strokeLinecap: opts.progressRoundedEdge ? 'round' : 'butt'
            });
        }, _this.renderNeedle = function (opts) {

            var x1 = opts.cX,
                y1 = opts.cY - opts.needleWidth / 2,
                x2 = opts.cX,
                y2 = opts.cY + opts.needleWidth / 2,
                x3 = opts.diameter,
                y3 = opts.cY,
                needleAngle = 360 * opts.currentValue / 100;

            var needleElm = null;
            if (opts.needleSharp) {
                needleElm = _react2.default.createElement('polygon', {
                    points: x1 + ',' + y1 + ' ' + x2 + ',' + y2 + ' ' + x3 + ',' + y3,
                    fill: opts.needleColor
                });
            } else {
                needleElm = _react2.default.createElement('line', {
                    x1: opts.cX,
                    y1: opts.cY,
                    x2: opts.diameter,
                    y2: opts.cY,
                    fill: 'none',
                    strokeWidth: opts.needleWidth,
                    stroke: opts.needleColor
                });
            }

            return _react2.default.createElement(
                'g',
                { className: 'needle' },
                _react2.default.createElement(
                    'g',
                    { transform: 'rotate(' + needleAngle + ' ' + opts.cX + ' ' + opts.cY + ')' },
                    needleElm
                ),
                _react2.default.createElement('circle', {
                    cx: opts.cX,
                    cy: opts.cY,
                    r: opts.needleBaseSize,
                    fill: opts.needleBaseColor
                })
            );
        }, _this.renderText = function (opts) {
            return _react2.default.createElement(
                'text',
                {
                    x: opts.cX,
                    y: opts.cY + 55,
                    fontFamily: opts.progressFont,
                    fontSize: opts.progressFontSize,
                    transform: 'rotate(90 ' + opts.cX + ' ' + opts.cY + ')',
                    textAnchor: 'middle',
                    fill: opts.progressColor
                },
                opts.currentValue
            );
        }, _temp), _possibleConstructorReturn(_this, _ret);
    }

    _createClass(Gauge, [{
        key: 'render',
        value: function render() {

            var opts = Object.assign({}, this.props);

            var _opts = opts,
                size = _opts.size,
                dialWidth = _opts.dialWidth;


            var cX = size / 2;
            var cY = size / 2;
            var radius = (size - 2 * dialWidth) / 2;
            var diameter = 2 * radius;
            var circumference = 2 * Math.PI * radius;
            opts = Object.assign(opts, {
                cX: cX,
                cY: cY,
                radius: radius,
                diameter: diameter,
                circumference: circumference
            });

            return _react2.default.createElement(
                'svg',
                {
                    xmlns: 'http://www.w3.org/2000/svg',
                    className: opts.className,
                    height: size,
                    width: size,
                    viewBox: '0 0 ' + size + ' ' + size
                },
                _react2.default.createElement(
                    'defs',
                    null,
                    this.defineTick(opts)
                ),
                _react2.default.createElement(
                    'g',
                    { transform: 'rotate(-90 ' + cX + ' ' + cY + ')' },
                    this.renderDial(opts),
                    this.renderTicks(opts),
                    this.renderProgress(opts),
                    this.renderNeedle(opts),
                    this.renderText(opts)
                )
            );
        }
    }]);

    return Gauge;
}(_react.Component);

Gauge.defaultProps = {
    size: 200,

    dialWidth: 10,
    dialColor: '#eee',

    tickLength: 3,
    tickWidth: 1,
    tickColor: '#cacaca',
    tickInterval: 10,

    maximumValue: 100,
    currentValue: 25,
    progressWidth: 5,
    progressColor: '#3d3d3d',
    progressRoundedEdge: true,
    downProgressColor: 'red',
    progressFont: 'Serif',
    progressFontSize: '40',

    needle: true,
    needleBaseSize: 5,
    needleBaseColor: '#9d9d9d',
    needleWidth: 2,
    needleSharp: false,
    needleColor: '#8a8a8a'
};

module.exports = Gauge;